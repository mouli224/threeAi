<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThreeAI - Working Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 30px; }
        .demo-section { 
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .input-group { 
            display: flex; 
            gap: 10px; 
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
        }
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 25px;
            background: #666;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .toggle-switch.enabled {
            background: #4CAF50;
        }
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s;
        }
        .toggle-switch.enabled .toggle-slider {
            transform: translateX(25px);
        }
        .credits-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        input { 
            flex: 1;
            min-width: 200px;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
        }
        button { 
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { background: #45a049; transform: translateY(-2px); }
        button:disabled { background: #666; cursor: not-allowed; transform: none; }
        .status { 
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }
        .viewer { 
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }
        #canvas { 
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ ThreeAI - Working Demo</h1>
            <p>AI-Powered 3D Generation with Hugging Face</p>
        </div>
        
        <div class="demo-section">
            <h2>üé® Generate 3D Model</h2>
            
            <!-- Credits Display -->
            <div id="creditsDisplay" class="credits-display">
                Loading credits...
            </div>
            
            <div class="input-group">
                <input type="text" id="promptInput" placeholder="Describe what you want to create (e.g., 'red sports car', 'wooden chair')" value="a red cube">
                
                <!-- HF Toggle -->
                <div class="toggle-container">
                    <span>ü§ñ Use AI (HF)</span>
                    <div id="hfToggle" class="toggle-switch" onclick="toggleHF()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                
                <button id="generateBtn" onclick="generateModel()">Generate</button>
            </div>
            
            <div id="status" class="status">Ready to generate! Enter a prompt above and click Generate.</div>
        </div>
        
        <div class="demo-section viewer">
            <h2>üåü 3D Viewer</h2>
            <canvas id="canvas" width="800" height="500"></canvas>
            <p style="margin-top: 15px; opacity: 0.8;">Use mouse to rotate, zoom, and pan the 3D model</p>
        </div>
    </div>

    <!-- Load scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="js/config.js"></script>
    <script src="js/huggingface-service.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="js/supabase-auth.js"></script>
    
    <script>
        let scene, camera, renderer, controls;
        let hfService;
        let isGenerating = false;
        let supabaseAuth = null;
        
        // Usage tracking
        let usage = {
            anonymous: {
                procedural: 0,
                maxProcedural: 3
            },
            registered: {
                ownerHf: 0,
                maxOwnerHf: 3,
                procedural: 0,
                maxProcedural: 999
            }
        };
        
        // UI state
        let hfEnabled = false;
        let isLoggedIn = false;
        
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            status.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            status.scrollTop = status.scrollHeight;
        }
        
        function updateCreditsDisplay() {
            const display = document.getElementById('creditsDisplay');
            
            if (isLoggedIn) {
                const hfUsed = usage.registered.ownerHf;
                const hfMax = usage.registered.maxOwnerHf;
                const procUsed = usage.registered.procedural;
                
                display.innerHTML = `
                    <div>‚úÖ Logged In | ü§ñ AI: ${hfUsed}/${hfMax} | üîß Procedural: ${procUsed}/Unlimited</div>
                `;
            } else {
                const procUsed = usage.anonymous.procedural;
                const procMax = usage.anonymous.maxProcedural;
                
                display.innerHTML = `
                    <div>üë§ Anonymous | üîß Procedural: ${procUsed}/${procMax} | ü§ñ AI requires login</div>
                `;
            }
        }
        
        function loadUsage() {
            const savedUsage = localStorage.getItem('threeai_usage');
            if (savedUsage) {
                try {
                    const parsed = JSON.parse(savedUsage);
                    usage.anonymous.procedural = parsed.anonymous?.procedural || 0;
                    usage.registered.ownerHf = parsed.registered?.ownerHf || 0;
                    usage.registered.procedural = parsed.registered?.procedural || 0;
                } catch (error) {
                    console.warn('Failed to load usage data:', error);
                }
            }
        }
        
        function saveUsage() {
            localStorage.setItem('threeai_usage', JSON.stringify(usage));
        }
        
        function toggleHF() {
            if (!isLoggedIn) {
                updateStatus('AI generation requires login. Please log in first.', 'warning');
                showLoginPrompt();
                return;
            }
            
            hfEnabled = !hfEnabled;
            const toggle = document.getElementById('hfToggle');
            
            if (hfEnabled) {
                toggle.classList.add('enabled');
                updateStatus('AI generation enabled', 'success');
            } else {
                toggle.classList.remove('enabled');
                updateStatus('Switched to procedural generation', 'info');
            }
            
            updateCreditsDisplay();
        }
        
        function showLoginPrompt() {
            if (supabaseAuth) {
                supabaseAuth.showAuthModal();
            } else {
                updateStatus('Authentication system not available', 'error');
            }
        }
        
        function initAuth() {
            try {
                if (typeof SupabaseAuth !== 'undefined') {
                    supabaseAuth = new SupabaseAuth();
                    
                    // Listen for auth changes
                    supabaseAuth.supabase.auth.onAuthStateChange((event, session) => {
                        if (session && session.user) {
                            isLoggedIn = true;
                            updateStatus(`Welcome ${session.user.email}!`, 'success');
                        } else {
                            isLoggedIn = false;
                            hfEnabled = false;
                            document.getElementById('hfToggle').classList.remove('enabled');
                        }
                        updateCreditsDisplay();
                    });
                    
                    updateStatus('Authentication system ready', 'success');
                } else {
                    updateStatus('Authentication not available (demo mode)', 'warning');
                }
            } catch (error) {
                updateStatus(`Auth initialization failed: ${error.message}`, 'error');
            }
        }
        
        function init3D() {
            const canvas = document.getElementById('canvas');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.width, canvas.height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(-1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add ground plane
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -2;
            plane.receiveShadow = true;
            scene.add(plane);
            
            // Add initial cube
            createDemoCube();
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            updateStatus('3D scene initialized successfully', 'success');
        }
        
        function createDemoCube() {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshLambertMaterial({ color: 0xff6b6b });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'demo-cube';
            scene.add(cube);
        }
        
        async function initializeAI() {
            try {
                if (typeof HUGGINGFACE_CONFIG === 'undefined') {
                    throw new Error('Hugging Face config not loaded');
                }
                
                const token = HUGGINGFACE_CONFIG.ownerToken;
                if (!token || !token.startsWith('hf_')) {
                    throw new Error('Invalid Hugging Face token');
                }
                
                hfService = new HuggingFaceService(token);
                updateStatus('Hugging Face service initialized', 'success');
                
                // Test token (skip if fails - generation might still work)
                try {
                    const response = await fetch('https://huggingface.co/api/whoami', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        updateStatus(`Token verified for user: ${data.name}`, 'success');
                    } else {
                        updateStatus('Token validation skipped (might still work for generation)', 'warning');
                    }
                } catch (error) {
                    updateStatus('Token validation skipped (might still work for generation)', 'warning');
                }
                
            } catch (error) {
                updateStatus(`AI initialization failed: ${error.message}`, 'error');
            }
        }
        
        async function generateModel() {
            if (isGenerating) return;
            
            const prompt = document.getElementById('promptInput').value.trim();
            if (!prompt) {
                updateStatus('Please enter a prompt', 'warning');
                return;
            }
            
            // Check credits
            if (!canGenerate()) {
                return;
            }
            
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';
            isGenerating = true;
            
            try {
                updateStatus(`Starting generation for: "${prompt}"`, 'info');
                
                // Remove existing generated models
                const objectsToRemove = [];
                scene.traverse((child) => {
                    if (child.isMesh && child.name !== 'demo-cube') {
                        objectsToRemove.push(child);
                    }
                });
                objectsToRemove.forEach(obj => scene.remove(obj));
                
                let result = null;
                
                if (hfEnabled && isLoggedIn) {
                    // Try HF generation
                    updateStatus('Using AI generation...', 'info');
                    try {
                        if (!hfService) {
                            throw new Error('Hugging Face service not initialized');
                        }
                        
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Generation timeout (60s)')), 60000)
                        );
                        
                        const generationPromise = hfService.generate3DModel(prompt, {
                            maxRetries: 2,
                            timeout: 50000
                        });
                        
                        result = await Promise.race([generationPromise, timeoutPromise]);
                        
                        if (result && result.vertices && result.vertices.length > 0) {
                            updateStatus(`AI model generated! Vertices: ${result.vertices.length / 3}`, 'success');
                            renderGeneratedModel(result);
                            
                            // Track HF usage
                            usage.registered.ownerHf++;
                            saveUsage();
                            updateCreditsDisplay();
                            
                            return;
                        }
                    } catch (error) {
                        updateStatus(`AI generation failed: ${error.message}`, 'warning');
                        updateStatus('Falling back to procedural generation...', 'info');
                    }
                }
                
                // Procedural generation (fallback or default)
                updateStatus('Using procedural generation...', 'info');
                createProceduralModel(prompt);
                
                // Track procedural usage
                if (isLoggedIn) {
                    usage.registered.procedural++;
                } else {
                    usage.anonymous.procedural++;
                }
                saveUsage();
                updateCreditsDisplay();
                
            } catch (error) {
                updateStatus(`Generation failed: ${error.message}`, 'error');
                createProceduralModel(prompt);
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate';
                isGenerating = false;
            }
        }
        
        function canGenerate() {
            if (hfEnabled && !isLoggedIn) {
                updateStatus('AI generation requires login', 'warning');
                showLoginPrompt();
                return false;
            }
            
            if (hfEnabled && isLoggedIn) {
                if (usage.registered.ownerHf >= usage.registered.maxOwnerHf) {
                    updateStatus('You\'ve used all 3 AI generations. Use your own HF token for more.', 'warning');
                    promptForUserToken();
                    return false;
                }
                return true;
            }
            
            // Procedural generation check
            if (!isLoggedIn) {
                if (usage.anonymous.procedural >= usage.anonymous.maxProcedural) {
                    updateStatus('You\'ve used all 3 free generations. Please log in for unlimited procedural generation.', 'warning');
                    showLoginPrompt();
                    return false;
                }
                return true;
            }
            
            // Logged in users have unlimited procedural
            return true;
        }
        
        function promptForUserToken() {
            const userToken = prompt('Enter your Hugging Face token for unlimited AI generations:');
            if (userToken && userToken.startsWith('hf_')) {
                // Update service with user token
                hfService = new HuggingFaceService(userToken);
                updateStatus('Using your personal HF token', 'success');
                // Reset counter or use different tracking for user tokens
            } else if (userToken) {
                updateStatus('Invalid token format. Should start with "hf_"', 'error');
            }
        }
        
        function renderGeneratedModel(modelData) {
            try {
                const geometry = new THREE.BufferGeometry();
                
                // Add vertices
                const vertices = new Float32Array(modelData.vertices);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                // Add faces if available
                if (modelData.faces) {
                    geometry.setIndex(modelData.faces);
                }
                
                // Add colors if available
                if (modelData.colors) {
                    const colors = new Float32Array(modelData.colors);
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                }
                
                geometry.computeVertexNormals();
                geometry.computeBoundingBox();
                
                // Create material
                const material = new THREE.MeshLambertMaterial({
                    color: 0x44aa88,
                    vertexColors: modelData.colors ? true : false
                });
                
                // Create mesh
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.name = 'generated-model';
                
                // Center the model
                const box = geometry.boundingBox;
                const center = box.getCenter(new THREE.Vector3());
                mesh.position.sub(center);
                
                scene.add(mesh);
                updateStatus('AI-generated model rendered successfully!', 'success');
                
            } catch (error) {
                updateStatus(`Failed to render model: ${error.message}`, 'error');
                createProceduralModel('fallback');
            }
        }
        
        function createProceduralModel(prompt) {
            // Create a procedural model based on the prompt
            let geometry, material;
            
            const lowerPrompt = prompt.toLowerCase();
            
            if (lowerPrompt.includes('cube') || lowerPrompt.includes('box')) {
                geometry = new THREE.BoxGeometry(2, 2, 2);
                material = new THREE.MeshLambertMaterial({ color: 0xff6b6b });
            } else if (lowerPrompt.includes('sphere') || lowerPrompt.includes('ball')) {
                geometry = new THREE.SphereGeometry(1.5, 32, 32);
                material = new THREE.MeshLambertMaterial({ color: 0x6bff6b });
            } else if (lowerPrompt.includes('cylinder')) {
                geometry = new THREE.CylinderGeometry(1, 1, 3, 32);
                material = new THREE.MeshLambertMaterial({ color: 0x6b6bff });
            } else {
                // Default complex shape
                geometry = new THREE.IcosahedronGeometry(1.5, 1);
                material = new THREE.MeshLambertMaterial({ color: 0xffaa44 });
            }
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.name = 'procedural-model';
            scene.add(mesh);
            
            updateStatus(`Created procedural model for: "${prompt}"`, 'success');
        }
        
        // Initialize everything when page loads
        window.addEventListener('load', async () => {
            updateStatus('Initializing ThreeAI Demo...', 'info');
            loadUsage();
            init3D();
            await initializeAI();
            initAuth();
            updateCreditsDisplay();
            updateStatus('Ready to generate! Try entering a prompt above.', 'success');
        });
        
        // Handle enter key in input
        document.getElementById('promptInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !isGenerating) {
                generateModel();
            }
        });
    </script>
</body>
</html>
